{"ast":null,"code":"//takeEvery listens to every action of a specific type we pass to it\nimport { takeLatest, call, put } from \"redux-saga/effects\";\nimport { firestore, convertCollectionSnapshotToMap } from \"../../firebase/firebase.utils\";\nimport { fetchCollectionSuccess, fetchCollectionFailure } from \"./shop.actions\";\nimport ShopActionTypes from \"./shop.types\"; //what saga middleware does is its whole purpose is to tun these sagas all concurrently\n//takeEvery creates a non blocking call in order to not stop our application to continue running, it does not pause the javascript for anything inside of\n//our fecth collections async to come back. alternatively\n\nexport function* fecthCollectionsAsync() {\n  yield console.log(\"I am fired\");\n\n  try {\n    const collectionRef = firestore.collection(\"collection\");\n    const snapshot = yield collectionRef.get(); //call is the effect inside of our generator function that invokes the method, it is a method that takes as its first argument some function or method\n    // and then the subsequent arguments will be the parameters that you passed into this function call\n\n    const collectionsMap = yield call(convertCollectionSnapshotToMap, snapshot);\n    yield put(fetchCollectionSuccess(collectionsMap));\n  } catch (error) {\n    //instead of dispatch keyword sagas use put effect. Put is the saga effect for creating action and it is exactly like dispatch.\n    //The only difference is we have to yield it\n    yield put(fetchCollectionFailure(error.message));\n  }\n} //what this saga does with the effect is it's going to pause whenever a specific action type that we want comes in\n\nexport function* fetchCollectionsStart() {\n  yield takeLatest(ShopActionTypes.FETCH_COLLECTION_START, fecthCollectionsAsync);\n}","map":{"version":3,"sources":["/Users/aliyevaparvana/Documents/Udemy/e-online-shop/src/redux/shop/shop.sagas.js"],"names":["takeLatest","call","put","firestore","convertCollectionSnapshotToMap","fetchCollectionSuccess","fetchCollectionFailure","ShopActionTypes","fecthCollectionsAsync","console","log","collectionRef","collection","snapshot","get","collectionsMap","error","message","fetchCollectionsStart","FETCH_COLLECTION_START"],"mappings":"AAAA;AACA,SAASA,UAAT,EAAqBC,IAArB,EAA2BC,GAA3B,QAAsC,oBAAtC;AACA,SACEC,SADF,EAEEC,8BAFF,QAGO,+BAHP;AAKA,SAASC,sBAAT,EAAiCC,sBAAjC,QAA+D,gBAA/D;AAEA,OAAOC,eAAP,MAA4B,cAA5B,C,CAEA;AACA;AACA;;AACA,OAAO,UAAUC,qBAAV,GAAkC;AACvC,QAAMC,OAAO,CAACC,GAAR,CAAY,YAAZ,CAAN;;AAEA,MAAI;AACF,UAAMC,aAAa,GAAGR,SAAS,CAACS,UAAV,CAAqB,YAArB,CAAtB;AAEA,UAAMC,QAAQ,GAAG,MAAMF,aAAa,CAACG,GAAd,EAAvB,CAHE,CAIF;AACA;;AACA,UAAMC,cAAc,GAAG,MAAMd,IAAI,CAACG,8BAAD,EAAiCS,QAAjC,CAAjC;AACA,UAAMX,GAAG,CAACG,sBAAsB,CAACU,cAAD,CAAvB,CAAT;AACD,GARD,CAQE,OAAOC,KAAP,EAAc;AACd;AACA;AACA,UAAMd,GAAG,CAACI,sBAAsB,CAACU,KAAK,CAACC,OAAP,CAAvB,CAAT;AACD;AACF,C,CACD;;AAEA,OAAO,UAAUC,qBAAV,GAAkC;AACvC,QAAMlB,UAAU,CACdO,eAAe,CAACY,sBADF,EAEdX,qBAFc,CAAhB;AAID","sourcesContent":["//takeEvery listens to every action of a specific type we pass to it\nimport { takeLatest, call, put } from \"redux-saga/effects\";\nimport {\n  firestore,\n  convertCollectionSnapshotToMap,\n} from \"../../firebase/firebase.utils\";\n\nimport { fetchCollectionSuccess, fetchCollectionFailure } from \"./shop.actions\";\n\nimport ShopActionTypes from \"./shop.types\";\n\n//what saga middleware does is its whole purpose is to tun these sagas all concurrently\n//takeEvery creates a non blocking call in order to not stop our application to continue running, it does not pause the javascript for anything inside of\n//our fecth collections async to come back. alternatively\nexport function* fecthCollectionsAsync() {\n  yield console.log(\"I am fired\");\n\n  try {\n    const collectionRef = firestore.collection(\"collection\");\n\n    const snapshot = yield collectionRef.get();\n    //call is the effect inside of our generator function that invokes the method, it is a method that takes as its first argument some function or method\n    // and then the subsequent arguments will be the parameters that you passed into this function call\n    const collectionsMap = yield call(convertCollectionSnapshotToMap, snapshot);\n    yield put(fetchCollectionSuccess(collectionsMap));\n  } catch (error) {\n    //instead of dispatch keyword sagas use put effect. Put is the saga effect for creating action and it is exactly like dispatch.\n    //The only difference is we have to yield it\n    yield put(fetchCollectionFailure(error.message));\n  }\n}\n//what this saga does with the effect is it's going to pause whenever a specific action type that we want comes in\n\nexport function* fetchCollectionsStart() {\n  yield takeLatest(\n    ShopActionTypes.FETCH_COLLECTION_START,\n    fecthCollectionsAsync\n  );\n}\n"]},"metadata":{},"sourceType":"module"}